"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PingPongReport = exports.PingPongType = void 0;
const packets_pb_1 = require("../../../../../proto/ai/inworld/packets/packets_pb");
const packet_id_entity_1 = require("../packet_id.entity");
var PingPongType;
(function (PingPongType) {
    // No type is specified, means this is empty report.
    PingPongType["UNSPECIFIED"] = "UNSPECIFIED";
    // Sent from the server to the client.
    PingPongType["PING"] = "PING";
    // Upon receiving a ping, the client has to send back a pong packet.
    PingPongType["PONG"] = "PONG";
})(PingPongType || (exports.PingPongType = PingPongType = {}));
class PingPongReport {
    constructor({ packetId, pingTimestamp, type, }) {
        this.packetId = packetId;
        this.pingTimestamp = pingTimestamp;
        this.type = type;
    }
    static fromProto(proto) {
        return new PingPongReport({
            packetId: proto.getPingPacketId()
                ? packet_id_entity_1.PacketId.fromProto(proto.getPingPacketId())
                : null,
            pingTimestamp: proto.getPingTimestamp(),
            type: this.getProtoPingPongReportType(proto.getType()),
        });
    }
    static getProtoPingPongReportType(type) {
        switch (type) {
            case packets_pb_1.PingPongReport.Type.PING:
                return PingPongType.PING;
            case packets_pb_1.PingPongReport.Type.PONG:
                return PingPongType.PONG;
            default:
                return PingPongType.UNSPECIFIED;
        }
    }
}
exports.PingPongReport = PingPongReport;

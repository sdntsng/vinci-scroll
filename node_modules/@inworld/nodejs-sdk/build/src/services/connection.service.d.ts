/// <reference types="node" />
import { ClientRequest } from '../../../proto/ai/inworld/engine/world-engine_pb';
import { InworldPacket as ProtoPacket } from '../../../proto/ai/inworld/packets/packets_pb';
import { ApiKey, Awaitable, ChangeSceneProps, ClientConfiguration, ConversationState, GenerateSessionTokenFn, GetterSetter, User } from '../common/data_structures';
import { ConvesationInterface, Extension } from '../common/data_structures/extension';
import { Character } from '../entities/character.entity';
import { SessionContinuation } from '../entities/continuation/session_continuation.entity';
import { InworldError } from '../entities/error.entity';
import { InworldPacket } from '../entities/packets/inworld_packet.entity';
import { Session } from '../entities/session.entity';
import { SessionToken } from '../entities/session_token.entity';
import { EventFactory } from '../factories/event';
interface ConnectionProps<InworldPacketT extends InworldPacket = InworldPacket> {
    apiKey: ApiKey;
    name?: string;
    user?: User;
    client?: ClientRequest;
    config?: ClientConfiguration;
    sessionGetterSetter?: GetterSetter<Session>;
    sessionContinuation?: SessionContinuation;
    onDisconnect?: () => Awaitable<void>;
    onError: (err: InworldError) => Awaitable<void>;
    onMessage?: (message: InworldPacketT) => Awaitable<void>;
    generateSessionToken?: GenerateSessionTokenFn;
    extension?: Extension<InworldPacketT>;
}
export declare class ConnectionService<InworldPacketT extends InworldPacket = InworldPacket> {
    private state;
    private config;
    private scene;
    private sceneIsLoaded;
    private sessionToken;
    private stream;
    private connectionProps;
    private disconnectTimeoutId;
    private eventFactory;
    private intervals;
    private packetQueue;
    private packetQueuePercievedLatency;
    private engineService;
    private stateService;
    private logger;
    private extension;
    private MAX_LATENCY_QUEUE_SIZE;
    onDisconnect: () => Awaitable<void>;
    onError: (err: InworldError) => Awaitable<void>;
    onMessage: ((message: ProtoPacket) => Awaitable<void>) | undefined;
    readonly conversations: Map<string, {
        service: ConvesationInterface<InworldPacketT>;
        state: ConversationState;
    }>;
    constructor(props: ConnectionProps<InworldPacketT>);
    isActive(): boolean;
    isAutoReconnected(): boolean;
    getSceneName(): string;
    getClientConfig(): ClientConfiguration;
    generateSessionToken(): Promise<SessionToken>;
    getSessionState(): Promise<import("./gprc/state_serialization_client_grpc.service").SessionState>;
    openManually(): Promise<void>;
    close(): void;
    getEventFactory(): EventFactory;
    getCharactersList(): Promise<Character[]>;
    getCurrentCharacter(): Promise<Character>;
    getCharactersByIds(ids: string[]): Character[];
    getCharactersByResourceNames(names: string[]): Character[];
    setCurrentCharacter(character: Character): void;
    removeCharacters(names: string[]): void;
    open(): Promise<void>;
    change(name: string, props?: ChangeSceneProps): Promise<void>;
    send(getPacket: () => ProtoPacket, props?: {
        force?: boolean;
    }): Promise<InworldPacketT>;
    private write;
    private writeToStream;
    private loadToken;
    ensureSessionToken(props?: {
        beforeLoading: () => void;
        sessionToken?: SessionToken;
    }): Promise<SessionToken>;
    addInterval(interval: NodeJS.Timeout): void;
    removeInterval(interval: NodeJS.Timeout): void;
    markPacketAsHandled(packet: InworldPacket): void;
    private scheduleDisconnect;
    private cancelScheduler;
    private releaseQueue;
    private clearQueue;
    private convertPacketFromProto;
    private ensureCurrentCharacter;
    private setSceneFromProtoEvent;
    private initializeHandlers;
    private initializeExtension;
    private buildConfiguration;
    private pushToPerceivedLatencyQueue;
    private findLastAudioSessionIndexes;
}
export {};

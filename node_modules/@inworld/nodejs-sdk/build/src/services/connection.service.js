"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionService = void 0;
const packets_pb_1 = require("../../../proto/ai/inworld/packets/packets_pb");
const data_structures_1 = require("../common/data_structures");
const logger_1 = require("../common/logger");
const capability_entity_1 = require("../entities/capability.entity");
const session_continuation_entity_1 = require("../entities/continuation/session_continuation.entity");
const control_entity_1 = require("../entities/packets/control.entity");
const inworld_packet_entity_1 = require("../entities/packets/inworld_packet.entity");
const scene_entity_1 = require("../entities/scene.entity");
const session_token_entity_1 = require("../entities/session_token.entity");
const event_1 = require("../factories/event");
const state_serialization_client_grpc_service_1 = require("./gprc/state_serialization_client_grpc.service");
const world_engine_client_grpc_service_1 = require("./gprc/world_engine_client_grpc.service");
class ConnectionService {
    constructor(props) {
        this.state = data_structures_1.ConnectionState.INACTIVE;
        this.sceneIsLoaded = false;
        this.eventFactory = new event_1.EventFactory();
        this.intervals = [];
        this.packetQueue = [];
        this.packetQueuePercievedLatency = [];
        this.engineService = new world_engine_client_grpc_service_1.WorldEngineClientGrpcService();
        this.stateService = new state_serialization_client_grpc_service_1.StateSerializationClientGrpcService();
        this.logger = logger_1.Logger.getInstance();
        this.MAX_LATENCY_QUEUE_SIZE = 50;
        this.conversations = new Map();
        this.connectionProps = props;
        this.scene = new scene_entity_1.Scene({
            name: this.connectionProps.name,
        });
        this.config = this.buildConfiguration(this.connectionProps.config);
        this.initializeHandlers();
        this.initializeExtension();
    }
    isActive() {
        return this.state === data_structures_1.ConnectionState.ACTIVE;
    }
    isAutoReconnected() {
        var _a, _b;
        return (_b = (_a = this.config.connection) === null || _a === void 0 ? void 0 : _a.autoReconnect) !== null && _b !== void 0 ? _b : true;
    }
    getSceneName() {
        return this.scene.name;
    }
    getClientConfig() {
        return this.connectionProps.config;
    }
    generateSessionToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const proto = yield this.engineService.generateSessionToken(this.connectionProps.apiKey, this.getSceneName());
            return session_token_entity_1.SessionToken.fromProto(proto);
        });
    }
    getSessionState() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const token = yield this.ensureSessionToken();
                return this.stateService.getSessionState({
                    sessionToken: token,
                    scene: this.getSceneName(),
                });
            }
            catch (err) {
                this.onError(err);
            }
        });
    }
    openManually() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.isAutoReconnected()) {
                    throw Error('Impossible to open connection manually with `autoReconnect` enabled');
                }
                if (this.isActive()) {
                    throw Error('Connection is already open');
                }
                return this.open();
            }
            catch (err) {
                this.onError(err);
            }
        });
    }
    close() {
        var _a, _b, _c;
        this.cancelScheduler();
        this.state = data_structures_1.ConnectionState.INACTIVE;
        (_a = this.stream) === null || _a === void 0 ? void 0 : _a.removeAllListeners('data');
        (_b = this.stream) === null || _b === void 0 ? void 0 : _b.cancel();
        this.clearQueue();
        if (this.stream) {
            this.logger.debug({
                action: 'Close connection',
                sessionId: (_c = this.sessionToken) === null || _c === void 0 ? void 0 : _c.sessionId,
            });
        }
    }
    getEventFactory() {
        return this.eventFactory;
    }
    getCharactersList() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.open();
            return this.scene.characters;
        });
    }
    getCurrentCharacter() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getCharactersList();
            return this.getEventFactory().getCurrentCharacter();
        });
    }
    getCharactersByIds(ids) {
        return this.scene.getCharactersByIds(ids);
    }
    getCharactersByResourceNames(names) {
        return this.scene.getCharactersByResourceNames(names);
    }
    setCurrentCharacter(character) {
        this.getEventFactory().setCurrentCharacter(character);
    }
    removeCharacters(names) {
        this.scene = new scene_entity_1.Scene(Object.assign(Object.assign({}, this.scene), { characters: this.scene.characters.filter((c) => !names.includes(c.resourceName)) }));
    }
    open() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state !== data_structures_1.ConnectionState.INACTIVE)
                return;
            try {
                yield this.loadToken();
                let stream;
                let sessionProto;
                if (this.sceneIsLoaded) {
                    stream = this.engineService.reopenSession({
                        sessionToken: this.sessionToken,
                        onError: this.onError,
                        onDisconnect: this.onDisconnect,
                        onMessage: this.onMessage,
                    });
                }
                else {
                    const { client, sessionContinuation, user } = this.connectionProps;
                    [stream, sessionProto] = yield this.engineService.openSession({
                        client,
                        sessionContinuation,
                        user,
                        name: this.getSceneName(),
                        config: this.config,
                        extension: this.extension,
                        sessionToken: this.sessionToken,
                        onError: this.onError,
                        onDisconnect: this.onDisconnect,
                        onMessage: this.onMessage,
                    });
                    this.sceneIsLoaded = true;
                    this.setSceneFromProtoEvent(sessionProto);
                }
                this.stream = stream;
                this.state = data_structures_1.ConnectionState.ACTIVE;
                this.releaseQueue();
                this.scheduleDisconnect();
            }
            catch (err) {
                this.onError(err);
                this.clearQueue();
            }
        });
    }
    change(name, props) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sceneIsLoaded) {
                throw Error('Unable to change scene that is not loaded yet');
            }
            this.connectionProps = Object.assign(Object.assign({}, this.connectionProps), { config: Object.assign(Object.assign(Object.assign({}, this.connectionProps.config), ((props === null || props === void 0 ? void 0 : props.capabilities) && {
                    capabilities: props.capabilities,
                })), ((props === null || props === void 0 ? void 0 : props.gameSessionId) && {
                    gameSessionId: props.gameSessionId,
                })), sessionContinuation: (props === null || props === void 0 ? void 0 : props.sessionContinuation)
                    ? new session_continuation_entity_1.SessionContinuation(props.sessionContinuation)
                    : undefined });
            this.config = this.buildConfiguration(this.connectionProps.config);
            if (!this.isActive()) {
                this.stream = this.engineService.reopenSession({
                    sessionToken: this.sessionToken,
                    onError: this.onError,
                    onDisconnect: this.onDisconnect,
                    onMessage: this.onMessage,
                });
            }
            const [, sessionProto] = yield this.engineService.updateSession({
                name: name !== this.getSceneName() ? name : undefined,
                sessionToken: this.sessionToken,
                connection: this.stream,
                capabilities: (props === null || props === void 0 ? void 0 : props.capabilities) && this.config.capabilities,
                gameSessionId: props === null || props === void 0 ? void 0 : props.gameSessionId,
                extension: this.extension,
                sessionContinuation: this.connectionProps.sessionContinuation,
                onMessage: this.onMessage,
            });
            if (sessionProto) {
                this.setSceneFromProtoEvent(sessionProto);
            }
        });
    }
    send(getPacket_1) {
        return __awaiter(this, arguments, void 0, function* (getPacket, props = {}) {
            try {
                this.cancelScheduler();
                if (!this.isActive() && !this.isAutoReconnected()) {
                    throw Error('Unable to send data due inactive connection');
                }
                return this.write(getPacket, props);
            }
            catch (err) {
                this.onError(err);
            }
        });
    }
    write(getPacket_1) {
        return __awaiter(this, arguments, void 0, function* (getPacket, props = {}) {
            let packet;
            const resolvePacket = () => new Promise((resolve) => {
                const done = (packet) => {
                    this.scheduleDisconnect();
                    resolve(this.convertPacketFromProto(packet));
                };
                if (packet) {
                    return done(packet);
                }
                const interval = setInterval(() => {
                    if (packet || this.state === data_structures_1.ConnectionState.INACTIVE) {
                        clearInterval(interval);
                        this.intervals = this.intervals.filter((i) => i !== interval);
                        done(packet);
                    }
                }, 10);
                this.intervals.push(interval);
            });
            if (this.isActive()) {
                packet = this.writeToStream(getPacket);
            }
            else {
                const item = {
                    getPacket,
                    afterWriting: (protoPacket) => {
                        packet = protoPacket;
                    },
                };
                if (props.force) {
                    this.packetQueue.unshift(item);
                }
                else {
                    this.packetQueue.push(item);
                }
                yield this.open();
            }
            return resolvePacket();
        });
    }
    writeToStream(getPacket) {
        var _a, _b, _c;
        const packet = getPacket();
        const inworldPacket = inworld_packet_entity_1.InworldPacket.fromProto(packet);
        if (inworldPacket.isNonSpeechPacket() ||
            inworldPacket.isPlayerTypeInText() ||
            inworldPacket.isPushToTalkAudioSessionStart()) {
            this.pushToPerceivedLatencyQueue([inworldPacket]);
        }
        else if (inworldPacket.isAudioSessionEnd()) {
            const found = this.packetQueuePercievedLatency.filter((item) => {
                return item.isPushToTalkAudioSessionStart() || item.isAudioSessionEnd();
            });
            if ((_a = found === null || found === void 0 ? void 0 : found[found.length - 1]) === null || _a === void 0 ? void 0 : _a.isPushToTalkAudioSessionStart()) {
                const interactionId = found[found.length - 1].packetId.interactionId;
                if (interactionId) {
                    const updatedAudioSessionEnd = new inworld_packet_entity_1.InworldPacket({
                        packetId: Object.assign(Object.assign({}, inworldPacket.packetId), { interactionId }),
                        control: new control_entity_1.ControlEvent({
                            action: data_structures_1.InworlControlAction.AUDIO_SESSION_END,
                        }),
                        routing: inworldPacket.routing,
                        date: inworldPacket.date,
                        type: data_structures_1.InworldPacketType.CONTROL,
                        proto: new packets_pb_1.InworldPacket(),
                    });
                    this.pushToPerceivedLatencyQueue([updatedAudioSessionEnd]);
                }
            }
        }
        (_b = this.stream) === null || _b === void 0 ? void 0 : _b.write(packet);
        this.logger.debug({
            action: 'Send packet',
            data: {
                packet: packet.toObject(),
            },
            sessionId: (_c = this.sessionToken) === null || _c === void 0 ? void 0 : _c.sessionId,
        });
        return packet;
    }
    loadToken() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (this.state === data_structures_1.ConnectionState.ACTIVATING)
                return;
            let session;
            // Try to get session from provided storage
            if (this.connectionProps.sessionGetterSetter) {
                session = yield this.connectionProps.sessionGetterSetter.get();
            }
            const previousSessionToken = this.sessionToken;
            yield this.ensureSessionToken({
                sessionToken: session === null || session === void 0 ? void 0 : session.sessionToken,
                beforeLoading: () => {
                    this.state = data_structures_1.ConnectionState.ACTIVATING;
                },
            });
            // Try to save session token to provided storage
            if (previousSessionToken !== this.sessionToken) {
                (_a = this.connectionProps.sessionGetterSetter) === null || _a === void 0 ? void 0 : _a.set({
                    sessionToken: this.sessionToken,
                });
            }
        });
    }
    ensureSessionToken(props) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let sessionToken = (_a = props === null || props === void 0 ? void 0 : props.sessionToken) !== null && _a !== void 0 ? _a : this.sessionToken;
            if (!sessionToken || session_token_entity_1.SessionToken.isExpired(sessionToken)) {
                const { sessionId } = sessionToken || {};
                // Generate new session token is it's empty or expired
                if (!sessionToken || session_token_entity_1.SessionToken.isExpired(sessionToken)) {
                    (_b = props === null || props === void 0 ? void 0 : props.beforeLoading) === null || _b === void 0 ? void 0 : _b.call(props);
                    const generateSessionToken = (_c = this.connectionProps.generateSessionToken) !== null && _c !== void 0 ? _c : this.generateSessionToken.bind(this);
                    sessionToken = yield generateSessionToken();
                    // Reuse session id to keep context of previous conversation
                    if (sessionId) {
                        sessionToken = new session_token_entity_1.SessionToken(Object.assign(Object.assign({}, sessionToken), { sessionId }));
                    }
                }
            }
            this.sessionToken = sessionToken;
            return this.sessionToken;
        });
    }
    addInterval(interval) {
        this.intervals.push(interval);
    }
    removeInterval(interval) {
        this.intervals = this.intervals.filter((i) => i !== interval);
    }
    // Handle percieved latency
    markPacketAsHandled(packet) {
        if (!this.config.capabilities.getPerceivedLatencyReport()) {
            return;
        }
        const sentIndex = this.packetQueuePercievedLatency.findIndex((item) => {
            const { packetId } = item;
            const relyOnSpeech = this.config.capabilities.getAudio() &&
                packet.isAudio() &&
                (item.isSpeechRecognitionResult() ||
                    item.isPlayerTypeInText() ||
                    item.isAudioSessionEnd());
            const relyOnNonSpeech = item.isNonSpeechPacket() || !this.config.capabilities.getAudio();
            return ((relyOnSpeech || relyOnNonSpeech) &&
                packetId.interactionId &&
                packetId.interactionId === packet.packetId.interactionId);
        });
        if (sentIndex > -1) {
            this.send(() => this.getEventFactory().perceivedLatencyWithTypeDetection({
                sent: this.packetQueuePercievedLatency[sentIndex],
                received: packet,
            }));
            this.packetQueuePercievedLatency.splice(sentIndex, 1);
        }
    }
    scheduleDisconnect() {
        var _a, _b;
        if ((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.disconnectTimeout) {
            this.cancelScheduler();
            this.disconnectTimeoutId = setTimeout(() => this.close(), this.config.connection.disconnectTimeout);
        }
    }
    cancelScheduler() {
        if (this.disconnectTimeoutId) {
            clearTimeout(this.disconnectTimeoutId);
        }
    }
    releaseQueue() {
        this.packetQueue.forEach((item) => {
            const protoPacket = this.writeToStream(item.getPacket);
            item.afterWriting(protoPacket);
        });
        this.packetQueue = [];
    }
    clearQueue() {
        this.intervals.forEach((i) => {
            clearInterval(i);
        });
        this.intervals = [];
        this.packetQueue = [];
        this.packetQueuePercievedLatency = [];
    }
    convertPacketFromProto(packet) {
        var _a;
        return ((_a = this.connectionProps.extension) === null || _a === void 0 ? void 0 : _a.convertPacketFromProto)
            ? this.connectionProps.extension.convertPacketFromProto(packet)
            : inworld_packet_entity_1.InworldPacket.fromProto(packet);
    }
    ensureCurrentCharacter() {
        const factory = this.getEventFactory();
        const currentCharacter = factory.getCurrentCharacter();
        const sameCharacter = currentCharacter
            ? this.scene.characters.find((c) => c.resourceName === (currentCharacter === null || currentCharacter === void 0 ? void 0 : currentCharacter.resourceName))
            : undefined;
        factory.setCurrentCharacter(sameCharacter !== null && sameCharacter !== void 0 ? sameCharacter : this.scene.characters[0]);
        factory.setCharacters(this.scene.characters);
    }
    setSceneFromProtoEvent(proto) {
        var _a, _b;
        this.scene = scene_entity_1.Scene.fromProto(proto);
        (_b = (_a = this.connectionProps.extension) === null || _a === void 0 ? void 0 : _a.afterLoadScene) === null || _b === void 0 ? void 0 : _b.call(_a, proto);
        this.ensureCurrentCharacter();
    }
    initializeHandlers() {
        this.onDisconnect = () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            this.state = data_structures_1.ConnectionState.INACTIVE;
            this.conversations.forEach((conversation) => {
                conversation.state = data_structures_1.ConversationState.INACTIVE;
            });
            yield ((_b = (_a = this.connectionProps).onDisconnect) === null || _b === void 0 ? void 0 : _b.call(_a));
        });
        this.onError = this.connectionProps.onError;
        this.onMessage = (packet) => __awaiter(this, void 0, void 0, function* () {
            var _c, _d, _e, _f, _g, _h, _j;
            const inworldPacket = this.convertPacketFromProto(packet);
            const conversationId = inworldPacket.packetId.conversationId;
            const conversation = conversationId && this.conversations.get(conversationId);
            const sceneStatus = (_c = packet.getControl()) === null || _c === void 0 ? void 0 : _c.getCurrentSceneStatus();
            if (inworldPacket.isSpeechRecognitionResult()) {
                const { indexStart, indexEnd } = this.findLastAudioSessionIndexes();
                if (indexStart >= 0 && indexEnd < indexStart) {
                    const audioSessionStart = this.packetQueuePercievedLatency[indexStart];
                    this.packetQueuePercievedLatency[indexStart] = new inworld_packet_entity_1.InworldPacket({
                        packetId: Object.assign(Object.assign({}, audioSessionStart === null || audioSessionStart === void 0 ? void 0 : audioSessionStart.packetId), { interactionId: inworldPacket.packetId.interactionId }),
                        control: new control_entity_1.ControlEvent(audioSessionStart.control),
                        routing: audioSessionStart.routing,
                        date: audioSessionStart === null || audioSessionStart === void 0 ? void 0 : audioSessionStart.date,
                        type: data_structures_1.InworldPacketType.CONTROL,
                        proto: new packets_pb_1.InworldPacket(),
                    });
                }
                else {
                    this.pushToPerceivedLatencyQueue([inworldPacket]);
                }
            }
            if (((_d = packet.getControl()) === null || _d === void 0 ? void 0 : _d.getAction()) ===
                packets_pb_1.ControlEvent.Action.CURRENT_SCENE_STATUS &&
                sceneStatus) {
                this.setSceneFromProtoEvent(sceneStatus);
            }
            // Update conversation state.
            if (((_e = inworldPacket.control) === null || _e === void 0 ? void 0 : _e.conversation) && conversation) {
                this.conversations.set(inworldPacket.packetId.conversationId, {
                    service: conversation.service,
                    state: [
                        data_structures_1.InworldConversationEventType.STARTED,
                        data_structures_1.InworldConversationEventType.UPDATED,
                    ].includes(inworldPacket.control.conversation.type)
                        ? data_structures_1.ConversationState.ACTIVE
                        : data_structures_1.ConversationState.INACTIVE,
                });
            }
            // Handle latency ping pong.
            if (inworldPacket.isPingPongReport()) {
                this.send(() => this.getEventFactory().pong(packet), { force: true });
                // Don't pass text packet outside.
                return;
            }
            (_g = (_f = this.connectionProps).onMessage) === null || _g === void 0 ? void 0 : _g.call(_f, inworldPacket);
            if (inworldPacket.isWarning()) {
                this.logger.warn({
                    action: 'Receive warning packet',
                    data: {
                        packet: packet.toObject(),
                    },
                    sessionId: (_h = this.sessionToken) === null || _h === void 0 ? void 0 : _h.sessionId,
                });
            }
            else {
                this.logger.debug({
                    action: 'Receive packet',
                    data: {
                        packet: packet.toObject(),
                    },
                    sessionId: (_j = this.sessionToken) === null || _j === void 0 ? void 0 : _j.sessionId,
                });
            }
        });
    }
    initializeExtension() {
        this.extension = Object.assign({ convertPacketFromProto: (proto) => inworld_packet_entity_1.InworldPacket.fromProto(proto) }, this.connectionProps.extension);
    }
    buildConfiguration(clientConfig = {}) {
        const { connection = {}, capabilities = {} } = clientConfig, restConfig = __rest(clientConfig, ["connection", "capabilities"]);
        return Object.assign(Object.assign({}, restConfig), { connection, capabilities: capability_entity_1.Capability.toProto(capabilities) });
    }
    pushToPerceivedLatencyQueue(packets) {
        if (!this.config.capabilities.getPerceivedLatencyReport()) {
            return;
        }
        this.packetQueuePercievedLatency.push(...packets);
        if (this.packetQueuePercievedLatency.length > this.MAX_LATENCY_QUEUE_SIZE) {
            this.packetQueuePercievedLatency.shift();
        }
    }
    findLastAudioSessionIndexes() {
        let indexStart = -1;
        let indexEnd = -1;
        for (let i = this.packetQueuePercievedLatency.length - 1; i >= 0 && indexStart < 0; i--) {
            if (this.packetQueuePercievedLatency[i].isPushToTalkAudioSessionStart()) {
                indexStart = i;
            }
        }
        for (let i = this.packetQueuePercievedLatency.length - 1; i >= 0 && indexEnd < 0; i--) {
            if (this.packetQueuePercievedLatency[i].isAudioSessionEnd()) {
                indexEnd = i;
            }
        }
        return { indexStart, indexEnd };
    }
}
exports.ConnectionService = ConnectionService;

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InworldConnectionService = void 0;
const data_structures_1 = require("../common/data_structures");
const data_structures_2 = require("../common/data_structures");
const errors_1 = require("../common/errors");
const event_1 = require("../factories/event");
const scene_1 = require("../guard/scene");
const conversation_service_1 = require("./conversation.service");
const entity_service_1 = require("./entity.service");
const feedback_service_1 = require("./feedback.service");
class InworldConnectionService {
    constructor(connection) {
        this.oneToOneConversationIntializeState = data_structures_1.ConversationIntializeState.INACTIVE;
        this.connection = connection;
        this.feedback = new feedback_service_1.FeedbackService(connection);
        this.entity = new entity_service_1.EntityService(connection);
    }
    getSessionState() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.connection.getSessionState();
        });
    }
    open() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.connection.openManually();
        });
    }
    close() {
        this.connection.close();
    }
    isActive() {
        return this.connection.isActive();
    }
    getCapabilities() {
        return this.connection.getClientConfig().capabilities;
    }
    getCharacters() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.connection.getCharactersList();
        });
    }
    getCurrentCharacter() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.connection.getCurrentCharacter();
        });
    }
    getCharacterById(id) {
        return this.connection.getCharactersByIds([id])[0];
    }
    getCharacterByResourceName(name) {
        return this.connection.getCharactersByResourceNames([name])[0];
    }
    setCurrentCharacter(character) {
        return __awaiter(this, void 0, void 0, function* () {
            this.connection.setCurrentCharacter(character);
            if (!this.oneToOneConversation) {
                this.oneToOneConversation = new conversation_service_1.ConversationService(this.connection, {
                    participants: [character.resourceName, data_structures_1.ConversationParticipant.USER],
                    addCharacters: this.addCharacters.bind(this),
                });
                this.addConversationToConnection(this.oneToOneConversation);
            }
            else {
                this.oneToOneConversation.changeParticipants([character.resourceName]);
            }
            if (this.connection.conversations.get(this.oneToOneConversation.getConversationId()).state === data_structures_2.ConversationState.ACTIVE) {
                yield this.oneToOneConversation.updateParticipants([
                    character.resourceName,
                    data_structures_1.ConversationParticipant.USER,
                ]);
            }
        });
    }
    getCurrentConversation() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureOneToOneConversation();
            return this.oneToOneConversation;
        });
    }
    getConversations() {
        return [...this.connection.conversations.entries()].map(([conversationId, conversation]) => ({
            conversationId,
            characters: conversation.service.getCharacters(),
        }));
    }
    sendText(text) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureOneToOneConversation();
            return this.oneToOneConversation.sendText(text);
        });
    }
    sendAudio(chunk) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureOneToOneConversation();
            return this.oneToOneConversation.sendAudio(chunk);
        });
    }
    sendTrigger(name, parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureOneToOneConversation();
            const character = yield this.getCurrentCharacter();
            if (parameters && Array.isArray(parameters)) {
                // TODO: Remove this deprecation warning in the next major release.
                console.warn('Passing parameters as an array is deprecated. Please use an object instead.');
                return this.oneToOneConversation.sendTrigger(name, {
                    parameters,
                    character,
                });
            }
            else if (!parameters || !Array.isArray(parameters)) {
                return this.oneToOneConversation.sendTrigger(name, {
                    parameters: parameters && !Array.isArray(parameters)
                        ? parameters.parameters
                        : undefined,
                    character,
                });
            }
        });
    }
    sendAudioSessionStart(params) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureOneToOneConversation();
            return this.oneToOneConversation.sendAudioSessionStart(params);
        });
    }
    sendAudioSessionEnd() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureOneToOneConversation();
            return this.oneToOneConversation.sendAudioSessionEnd();
        });
    }
    sendTTSPlaybackMute(isMuted) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureOneToOneConversation();
            return this.oneToOneConversation.sendTTSPlaybackMute(isMuted);
        });
    }
    sendCancelResponse(cancelResponses) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureOneToOneConversation();
            return this.oneToOneConversation.sendCancelResponse(cancelResponses);
        });
    }
    sendNarratedAction(text) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureOneToOneConversation();
            return this.oneToOneConversation.sendNarratedAction(text);
        });
    }
    sendPerceivedLatenctReport(props) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureOneToOneConversation();
            return this.oneToOneConversation.sendPerceivedLatenctReport(props);
        });
    }
    reloadScene() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Remove this deprecation warning in the next major release.
            console.warn('Reload scene is deprecated. Please use changeScene instead.');
            yield this.changeScene(this.connection.getSceneName());
        });
    }
    changeScene(name, props) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!(0, scene_1.sceneHasValidFormat)(name)) {
                throw Error(errors_1.SCENE_HAS_INVALID_FORMAT);
            }
            // Clear all conversations
            if (name !== this.connection.getSceneName()) {
                const id = (_a = this.oneToOneConversation) === null || _a === void 0 ? void 0 : _a.getConversationId();
                const existingConversation = this.connection.conversations.get(id);
                if (existingConversation) {
                    this.connection.conversations.delete(id);
                }
                this.oneToOneConversation = undefined;
                this.oneToOneConversationIntializeState =
                    data_structures_1.ConversationIntializeState.INACTIVE;
            }
            return this.connection.change(name, props);
        });
    }
    addCharacters(names) {
        return __awaiter(this, void 0, void 0, function* () {
            const invalid = names.find((name) => !(0, scene_1.characterHasValidFormat)(name));
            if (invalid) {
                throw Error(errors_1.CHARACTER_HAS_INVALID_FORMAT);
            }
            const result = yield this.connection.send(() => event_1.EventFactory.loadCharacters(names));
            yield this.resolveInterval(() => {
                const found = this.connection.getCharactersByResourceNames(names);
                return found.length && found.length === names.length;
            });
            return result;
        });
    }
    removeCharacters(names) {
        return __awaiter(this, void 0, void 0, function* () {
            const invalid = names.find((name) => !(0, scene_1.characterHasValidFormat)(name));
            if (invalid) {
                throw Error(errors_1.CHARACTER_HAS_INVALID_FORMAT);
            }
            const ids = (yield this.getCharacters())
                .filter((c) => names.includes(c.resourceName))
                .map((c) => c.id);
            const result = yield this.connection.send(() => event_1.EventFactory.unloadCharacters(ids));
            this.connection.removeCharacters(names);
            this.connection.conversations.forEach((conversation) => {
                conversation.service.changeParticipants(conversation.service
                    .getCharacters()
                    .filter((c) => !names.includes(c.resourceName))
                    .map((c) => c.resourceName));
            });
            return result;
        });
    }
    sendCustomPacket(getPacket) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureOneToOneConversation();
            return this.oneToOneConversation.sendCustomPacket(getPacket);
        });
    }
    startConversation(participants) {
        const service = new conversation_service_1.ConversationService(this.connection, {
            participants,
            addCharacters: this.addCharacters.bind(this),
        });
        this.connection.conversations.set(service.getConversationId(), {
            service,
            state: data_structures_2.ConversationState.INACTIVE,
        });
        return service;
    }
    baseProtoPacket(props) {
        return this.connection.getEventFactory().baseProtoPacket(props);
    }
    markPacketAsHandled(packet) {
        return this.connection.markPacketAsHandled(packet);
    }
    ensureOneToOneConversation() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.oneToOneConversationIntializeState ===
                data_structures_1.ConversationIntializeState.INACTIVE) {
                this.oneToOneConversationIntializeState =
                    data_structures_1.ConversationIntializeState.PROCESSING;
                const character = yield this.getCurrentCharacter();
                if (!character) {
                    throw Error(errors_1.CURRENT_CHARACTER_NOT_SET);
                }
                this.oneToOneConversation = new conversation_service_1.ConversationService(this.connection, {
                    participants: [character.resourceName, data_structures_1.ConversationParticipant.USER],
                    addCharacters: this.addCharacters.bind(this),
                });
                this.addConversationToConnection(this.oneToOneConversation);
                this.oneToOneConversationIntializeState =
                    data_structures_1.ConversationIntializeState.ACTIVE;
            }
            else {
                return new Promise((resolve) => {
                    const interval = setInterval(() => {
                        if (this.oneToOneConversationIntializeState ===
                            data_structures_1.ConversationIntializeState.ACTIVE) {
                            clearInterval(interval);
                            this.connection.removeInterval(interval);
                            resolve();
                        }
                    }, 10);
                    this.connection.addInterval(interval);
                });
            }
        });
    }
    resolveInterval(done) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                const interval = setInterval(() => {
                    if (done()) {
                        clearInterval(interval);
                        this.connection.removeInterval(interval);
                        resolve();
                    }
                }, 10);
                this.connection.addInterval(interval);
            });
        });
    }
    addConversationToConnection(conversation) {
        if (!this.connection.conversations.has(conversation.getConversationId())) {
            this.connection.conversations.set(conversation.getConversationId(), {
                service: conversation,
                state: data_structures_2.ConversationState.INACTIVE,
            });
        }
    }
}
exports.InworldConnectionService = InworldConnectionService;

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorldEngineClientGrpcService = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const configuration_pb_1 = require("../../../../proto/ai/inworld/engine/configuration/configuration_pb");
const world_engine_grpc_pb_1 = require("../../../../proto/ai/inworld/engine/world-engine_grpc_pb");
const world_engine_pb_1 = require("../../../../proto/ai/inworld/engine/world-engine_pb");
const packets_pb_1 = require("../../../../proto/ai/inworld/packets/packets_pb");
const util_1 = require("util");
const os = require("os");
const key_signature_1 = require("../../auth/key_signature");
const config_1 = require("../../common/config");
const constants_1 = require("../../common/constants");
const helpers_1 = require("../../common/helpers");
const logger_1 = require("../../common/logger");
const error_entity_1 = require("../../entities/error.entity");
const event_1 = require("../../factories/event");
const { version } = require('../../../../package.json');
class WorldEngineClientGrpcService {
    constructor() {
        this.config = config_1.Config.getInstance();
        this.address = this.config.getHost();
        this.ssl = this.config.getSSL();
        this.grpcOptions = Object.assign({}, helpers_1.grpcOptions);
        this.client = new world_engine_grpc_pb_1.WorldEngineClient(this.config.getHost(), this.ssl ? grpc_js_1.credentials.createSsl() : grpc_js_1.credentials.createInsecure(), Object.assign({}, helpers_1.grpcOptions));
        this.logger = logger_1.Logger.getInstance();
    }
    generateSessionToken(apiKey, scene) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = new grpc_js_1.Metadata();
            const request = new world_engine_pb_1.GenerateTokenRequest();
            const resource = `workspaces/${constants_1.SCENE_PATTERN.exec(scene)[1]}`;
            request.setKey(apiKey.key);
            request.setResourcesList([resource]);
            metadata.add('authorization', key_signature_1.KeySignature.getAuthorization({
                apiKey,
                host: this.config.getHost(),
            }));
            const response = yield (0, util_1.promisify)(this.client.generateToken.bind(this.client))(request, metadata);
            this.logger.debug({
                action: 'Generate token',
                data: {
                    address: this.address,
                    ssl: this.ssl,
                    request: request.toObject(),
                    response: response.toObject(),
                },
            });
            return response;
        });
    }
    openSession(props) {
        const { sessionToken, onDisconnect, onError, onMessage } = props;
        const metadata = this.getMetadata(sessionToken);
        const connection = this.client.openSession(metadata);
        this.logger.debug({
            action: 'Open session',
            data: {
                address: this.address,
                ssl: this.ssl,
                grpcOptions: this.grpcOptions,
            },
            sessionId: sessionToken.sessionId,
        });
        if (onDisconnect) {
            connection.on('close', onDisconnect);
        }
        if (onError) {
            connection.on('error', (err) => {
                onError(error_entity_1.InworldError.fromProto(err));
                connection.end();
            });
        }
        this.writeInitialPackets({
            extension: props.extension,
            capabilities: props.config.capabilities,
            client: props.client,
            gameSessionId: props.config.gameSessionId,
            name: props.name,
            sessionContinuation: props.sessionContinuation,
            user: props.user,
            useDefaultClient: !props.client,
            sessionToken,
            connection,
        });
        return new Promise((resolve) => {
            connection.on('data', this.onLoad({
                connection,
                resolve,
                onMessage,
            }));
        });
    }
    reopenSession(props) {
        const { sessionToken, onDisconnect, onError, onMessage } = props;
        const metadata = this.getMetadata(sessionToken);
        const connection = this.client.openSession(metadata);
        this.logger.debug({
            action: 'Reopen session',
            data: {
                address: this.address,
                ssl: this.ssl,
                grpcOptions: this.grpcOptions,
            },
            sessionId: sessionToken.sessionId,
        });
        if (onDisconnect) {
            connection.on('close', onDisconnect);
        }
        if (onError) {
            connection.on('error', (err) => {
                onError(error_entity_1.InworldError.fromProto(err));
                connection.end();
            });
        }
        if (onMessage) {
            connection.on('data', onMessage);
        }
        return connection;
    }
    updateSession(props) {
        const { connection, onMessage, sessionToken } = props;
        this.logger.debug({
            action: 'Update session',
            data: {
                address: this.address,
                ssl: this.ssl,
                grpcOptions: this.grpcOptions,
            },
            sessionId: sessionToken.sessionId,
        });
        this.writeInitialPackets({
            extension: props.extension,
            capabilities: props.capabilities,
            gameSessionId: props.gameSessionId,
            name: props.name,
            sessionContinuation: props.sessionContinuation,
            sessionToken,
            connection,
        });
        if (!props.name)
            return [];
        connection.removeAllListeners('data');
        return new Promise((resolve) => {
            connection.on('data', this.onLoad({
                connection,
                resolve,
                onMessage,
            }));
        });
    }
    onLoad(props) {
        let loaded = false;
        const { connection, onMessage, resolve } = props;
        return (packet) => {
            var _a;
            onMessage(packet);
            if (!loaded && ((_a = packet === null || packet === void 0 ? void 0 : packet.getControl()) === null || _a === void 0 ? void 0 : _a.hasCurrentSceneStatus())) {
                loaded = true;
                connection.removeAllListeners('data');
                if (onMessage) {
                    connection.on('data', onMessage);
                }
                resolve([connection, packet.getControl().getCurrentSceneStatus()]);
            }
        };
    }
    getMetadata(sessionToken) {
        const metadata = new grpc_js_1.Metadata();
        metadata.add('session-id', sessionToken.sessionId);
        metadata.add('authorization', `${sessionToken.type} ${sessionToken.token}`);
        return metadata;
    }
    getClient(props) {
        var _a;
        const containerInfo = `${os.type()} ${os.release()} (Node.js ${process.version})`;
        const description = [constants_1.CLIENT_ID, version, containerInfo];
        if ((_a = props.client) === null || _a === void 0 ? void 0 : _a.getId()) {
            description.push(props.client.getId());
        }
        return new world_engine_pb_1.ClientRequest()
            .setId(constants_1.CLIENT_ID)
            .setVersion(version)
            .setDescription(description.join('; '));
    }
    getUserConfiguration(props) {
        var _a, _b;
        const { user } = props;
        const userConfiguration = new configuration_pb_1.UserConfiguration();
        if ((_b = (_a = user === null || user === void 0 ? void 0 : user.profile) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b.length) {
            const settings = new world_engine_pb_1.UserSettings().setPlayerProfile(new world_engine_pb_1.UserSettings.PlayerProfile().setFieldsList(user.profile.fields.map(({ id, value }) => new world_engine_pb_1.UserSettings.PlayerProfile.PlayerField()
                .setFieldId(id)
                .setFieldValue(value))));
            userConfiguration.setUserSettings(settings);
        }
        if (user === null || user === void 0 ? void 0 : user.fullName) {
            userConfiguration.setName(user.fullName);
        }
        return userConfiguration;
    }
    getContinuation(props) {
        const { sessionContinuation } = props;
        const continuation = new packets_pb_1.Continuation();
        if (sessionContinuation === null || sessionContinuation === void 0 ? void 0 : sessionContinuation.previousState) {
            continuation
                .setContinuationType(packets_pb_1.Continuation.ContinuationType
                .CONTINUATION_TYPE_EXTERNALLY_SAVED_STATE)
                .setExternallySavedState(sessionContinuation.previousState);
        }
        else if (sessionContinuation === null || sessionContinuation === void 0 ? void 0 : sessionContinuation.previousDialog) {
            continuation
                .setContinuationType(packets_pb_1.Continuation.ContinuationType.CONTINUATION_TYPE_DIALOG_HISTORY)
                .setDialogHistory(sessionContinuation.previousDialog.toProto());
        }
        return continuation.getContinuationType() ? continuation : undefined;
    }
    writeInitialPackets(props) {
        var _a, _b;
        const continuation = this.getContinuation(props);
        const packets = [
            event_1.EventFactory.sessionControl(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (props.capabilities && {
                capabilities: props.capabilities,
            })), (props.gameSessionId && {
                sessionConfiguration: new configuration_pb_1.SessionConfiguration().setGameSessionId(props.gameSessionId),
            })), ((props.client || props.useDefaultClient) && {
                clientConfiguration: this.getClient({
                    client: props.client,
                }),
            })), (props.user && {
                userConfiguration: this.getUserConfiguration(props),
            })), (continuation && { continuation }))),
        ];
        if (props.name) {
            packets.push(event_1.EventFactory.loadScene(props.name));
        }
        const finalPackets = ((_b = (_a = props.extension).beforeLoadScene) === null || _b === void 0 ? void 0 : _b.call(_a, packets)) || packets;
        for (const packet of finalPackets) {
            props.connection.write(packet);
            this.logger.debug({
                action: 'Send packet',
                data: {
                    packet: packet.toObject(),
                },
                sessionId: props.sessionToken.sessionId,
            });
        }
    }
}
exports.WorldEngineClientGrpcService = WorldEngineClientGrpcService;

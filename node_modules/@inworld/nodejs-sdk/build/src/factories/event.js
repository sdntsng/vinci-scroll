"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventFactory = void 0;
const packets_pb_1 = require("../../../proto/ai/inworld/packets/packets_pb");
const uuid_1 = require("uuid");
const data_structures_1 = require("../common/data_structures");
const helpers_1 = require("../common/helpers");
const item_operation_1 = require("../entities/entities/item_operation");
const perceived_latency_report_1 = require("../entities/packets/latency/perceived_latency_report");
class EventFactory {
    constructor() {
        this.character = undefined;
        this.characters = [];
    }
    getCurrentCharacter() {
        return this.character;
    }
    setCurrentCharacter(character) {
        this.character = character;
    }
    setCharacters(characters) {
        this.characters = characters;
    }
    getCharacters() {
        return this.characters;
    }
    dataChunk(chunk, type, params) {
        const event = new packets_pb_1.DataChunk().setType(type).setChunk(chunk);
        return this.baseProtoPacket({
            utteranceId: false,
            interactionId: false,
            conversationId: params.conversationId,
        }).setDataChunk(event);
    }
    audioSessionStart(params) {
        return this.audioSession(packets_pb_1.ControlEvent.Action.AUDIO_SESSION_START, params);
    }
    audioSessionEnd(params) {
        return this.audioSession(packets_pb_1.ControlEvent.Action.AUDIO_SESSION_END, params);
    }
    pong(initialPacket) {
        const packetId = initialPacket.getPacketId();
        const event = new packets_pb_1.LatencyReportEvent().setPingPong(new packets_pb_1.PingPongReport()
            .setPingPacketId(new packets_pb_1.PacketId()
            .setPacketId(packetId.getPacketId())
            .setConversationId(packetId.getConversationId())
            .setInteractionId(packetId.getInteractionId())
            .setCorrelationId(packetId.getCorrelationId()))
            .setPingTimestamp(initialPacket.getLatencyReport().getPingPong().getPingTimestamp())
            .setType(packets_pb_1.PingPongReport.Type.PONG));
        return this.baseProtoPacket({
            utteranceId: false,
            interactionId: false,
        }).setLatencyReport(event);
    }
    perceivedLatencyWithTypeDetection({ sent, received, }) {
        const duration = (0, helpers_1.calculateTimeDifference)((0, helpers_1.protoTimestamp)(new Date(sent.date)), (0, helpers_1.protoTimestamp)(new Date()));
        let precision = packets_pb_1.PerceivedLatencyReport.Precision.UNSPECIFIED;
        if (sent.isAudioSessionEnd()) {
            precision = packets_pb_1.PerceivedLatencyReport.Precision.PUSH_TO_TALK;
        }
        else if ((sent.isPlayerTypeInText() || sent.isSpeechRecognitionResult()) &&
            received.isAudio()) {
            precision = packets_pb_1.PerceivedLatencyReport.Precision.ESTIMATED;
        }
        else if (sent.isNonSpeechPacket() || sent.isPlayerTypeInText()) {
            precision = packets_pb_1.PerceivedLatencyReport.Precision.NON_SPEECH;
        }
        const event = new packets_pb_1.LatencyReportEvent().setPerceivedLatency(new packets_pb_1.PerceivedLatencyReport()
            .setLatency(duration)
            .setPrecision(precision));
        const basePacket = this.baseProtoPacket({
            utteranceId: false,
            interactionId: false,
        });
        const basePacketId = basePacket.getPacketId();
        return basePacket
            .setPacketId(new packets_pb_1.PacketId()
            .setPacketId(basePacketId.getPacketId())
            .setConversationId(basePacketId.getConversationId())
            .setInteractionId(received.packetId.interactionId)
            .setCorrelationId(basePacketId.getCorrelationId())
            .setUtteranceId(basePacketId.getUtteranceId()))
            .setLatencyReport(event);
    }
    perceivedLatency({ precision, interactionId, startDate, endDate, }) {
        const duration = (0, helpers_1.calculateTimeDifference)((0, helpers_1.protoTimestamp)(startDate), (0, helpers_1.protoTimestamp)(endDate));
        const event = new packets_pb_1.LatencyReportEvent().setPerceivedLatency(new packets_pb_1.PerceivedLatencyReport()
            .setLatency(duration)
            .setPrecision(perceived_latency_report_1.PerceivedLatencyReport.getProtoPerceivedLatencyReportPrecision(precision)));
        const basePacket = this.baseProtoPacket({
            utteranceId: false,
            interactionId: false,
        });
        const basePacketId = basePacket.getPacketId();
        return basePacket
            .setPacketId(new packets_pb_1.PacketId()
            .setPacketId(basePacketId.getPacketId())
            .setInteractionId(interactionId))
            .setLatencyReport(event);
    }
    mutePlayback(isMuted, params) {
        const event = new packets_pb_1.ControlEvent().setAction(isMuted
            ? packets_pb_1.ControlEvent.Action.TTS_PLAYBACK_MUTE
            : packets_pb_1.ControlEvent.Action.TTS_PLAYBACK_UNMUTE);
        return this.baseProtoPacket({
            utteranceId: false,
            interactionId: false,
            conversationId: params.conversationId,
        }).setControl(event);
    }
    text(text, params) {
        const event = new packets_pb_1.TextEvent()
            .setText(text)
            .setSourceType(packets_pb_1.TextEvent.SourceType.TYPED_IN)
            .setFinal(true);
        return this.baseProtoPacket({
            correlationId: true,
            conversationId: params.conversationId,
        }).setText(event);
    }
    trigger(name, params) {
        return this.customEvent(name, packets_pb_1.CustomEvent.Type.TRIGGER, params);
    }
    cancelResponse(params) {
        const event = new packets_pb_1.CancelResponsesEvent();
        if (params.interactionId) {
            event.setInteractionId(params.interactionId);
        }
        if (params.utteranceId) {
            event.setUtteranceIdList(params.utteranceId);
        }
        return this.baseProtoPacket({
            utteranceId: false,
            interactionId: false,
            correlationId: true,
        })
            .setMutation(new packets_pb_1.MutationEvent().setCancelResponses(event))
            .setRouting(this.routing({
            character: params.character,
        }));
    }
    narratedAction(content, params) {
        const event = new packets_pb_1.ActionEvent().setNarratedAction(new packets_pb_1.NarratedAction().setContent(content));
        return this.baseProtoPacket({
            correlationId: true,
            conversationId: params.conversationId,
        }).setAction(event);
    }
    static conversation(participants, params) {
        const control = new packets_pb_1.ControlEvent()
            .setAction(packets_pb_1.ControlEvent.Action.CONVERSATION_UPDATE)
            .setConversationUpdate(new packets_pb_1.ConversationUpdatePayload().setParticipantsList(participants.map((p) => p === data_structures_1.ConversationParticipant.USER
            ? new packets_pb_1.Actor().setType(packets_pb_1.Actor.Type.PLAYER)
            : new packets_pb_1.Actor().setName(p).setType(packets_pb_1.Actor.Type.AGENT))));
        return new packets_pb_1.InworldPacket()
            .setPacketId(new packets_pb_1.PacketId()
            .setPacketId((0, uuid_1.v4)())
            .setConversationId(params.conversationId))
            .setTimestamp((0, helpers_1.protoTimestamp)())
            .setControl(control);
    }
    static sessionControl(props) {
        const event = new packets_pb_1.SessionConfigurationPayload();
        if (props.capabilities) {
            event.setCapabilitiesConfiguration(props.capabilities);
        }
        if (props.sessionConfiguration) {
            event.setSessionConfiguration(props.sessionConfiguration);
        }
        if (props.clientConfiguration) {
            event.setClientConfiguration(props.clientConfiguration);
        }
        if (props.userConfiguration) {
            event.setUserConfiguration(props.userConfiguration);
        }
        if (props.continuation) {
            event.setContinuation(props.continuation);
        }
        return new packets_pb_1.InworldPacket()
            .setPacketId(new packets_pb_1.PacketId().setPacketId((0, uuid_1.v4)()))
            .setRouting(this.worldRouting())
            .setTimestamp((0, helpers_1.protoTimestamp)())
            .setControl(new packets_pb_1.ControlEvent()
            .setAction(packets_pb_1.ControlEvent.Action.SESSION_CONFIGURATION)
            .setSessionConfiguration(event));
    }
    static loadScene(name) {
        const mutation = new packets_pb_1.MutationEvent().setLoadScene(new packets_pb_1.LoadScene().setName(name));
        return new packets_pb_1.InworldPacket()
            .setPacketId(new packets_pb_1.PacketId().setPacketId((0, uuid_1.v4)()))
            .setRouting(this.worldRouting())
            .setTimestamp((0, helpers_1.protoTimestamp)())
            .setMutation(mutation);
    }
    static loadCharacters(names) {
        const characters = new packets_pb_1.LoadCharacters().setNameList(names.map((name) => new packets_pb_1.LoadCharacters.CharacterName().setName(name)));
        const mutation = new packets_pb_1.MutationEvent().setLoadCharacters(characters);
        return new packets_pb_1.InworldPacket()
            .setPacketId(new packets_pb_1.PacketId().setPacketId((0, uuid_1.v4)()))
            .setRouting(this.worldRouting())
            .setTimestamp((0, helpers_1.protoTimestamp)())
            .setMutation(mutation);
    }
    static unloadCharacters(ids) {
        const agents = ids.map((agentId) => new packets_pb_1.Agent().setAgentId(agentId));
        const mutation = new packets_pb_1.MutationEvent().setUnloadCharacters(new packets_pb_1.UnloadCharacters().setAgentsList(agents));
        return new packets_pb_1.InworldPacket()
            .setPacketId(new packets_pb_1.PacketId().setPacketId((0, uuid_1.v4)()))
            .setRouting(this.worldRouting())
            .setTimestamp((0, helpers_1.protoTimestamp)())
            .setMutation(mutation);
    }
    static createOrUpdateItems(props) {
        return new packets_pb_1.InworldPacket()
            .setPacketId(new packets_pb_1.PacketId().setPacketId((0, uuid_1.v4)()))
            .setRouting(this.worldRouting())
            .setTimestamp((0, helpers_1.protoTimestamp)())
            .setEntitiesItemsOperation(new item_operation_1.ItemOperation({
            createOrUpdateItems: props,
        }).toProto());
    }
    static removeItems(ids) {
        return new packets_pb_1.InworldPacket()
            .setPacketId(new packets_pb_1.PacketId().setPacketId((0, uuid_1.v4)()))
            .setRouting(this.worldRouting())
            .setTimestamp((0, helpers_1.protoTimestamp)())
            .setEntitiesItemsOperation(new item_operation_1.ItemOperation({
            removeItems: { itemIds: ids },
        }).toProto());
    }
    static itemsInEntities(props) {
        return new packets_pb_1.InworldPacket()
            .setPacketId(new packets_pb_1.PacketId().setPacketId((0, uuid_1.v4)()))
            .setRouting(this.worldRouting())
            .setTimestamp((0, helpers_1.protoTimestamp)())
            .setEntitiesItemsOperation(new item_operation_1.ItemOperation({
            itemsInEntities: props,
        }).toProto());
    }
    baseProtoPacket(props) {
        const packetId = new packets_pb_1.PacketId().setPacketId((0, uuid_1.v4)());
        if ((props === null || props === void 0 ? void 0 : props.utteranceId) !== false) {
            packetId.setUtteranceId((0, uuid_1.v4)());
        }
        if ((props === null || props === void 0 ? void 0 : props.interactionId) !== false) {
            packetId.setInteractionId((0, uuid_1.v4)());
        }
        if (props === null || props === void 0 ? void 0 : props.correlationId) {
            packetId.setCorrelationId((0, uuid_1.v4)());
        }
        if (props === null || props === void 0 ? void 0 : props.conversationId) {
            packetId.setConversationId(props.conversationId);
        }
        return new packets_pb_1.InworldPacket()
            .setPacketId(packetId)
            .setRouting(this.routing())
            .setTimestamp((0, helpers_1.protoTimestamp)());
    }
    audioSession(action, params) {
        const event = new packets_pb_1.ControlEvent().setAction(action);
        if (action === packets_pb_1.ControlEvent.Action.AUDIO_SESSION_START) {
            let protoMode;
            switch (params.mode) {
                case data_structures_1.MicrophoneMode.EXPECT_AUDIO_END:
                    protoMode = packets_pb_1.AudioSessionStartPayload.MicrophoneMode.EXPECT_AUDIO_END;
                    break;
                default:
                    protoMode = packets_pb_1.AudioSessionStartPayload.MicrophoneMode.OPEN_MIC;
                    break;
            }
            let protoUnderstandingMode;
            switch (params.understandingMode) {
                case data_structures_1.UnderstandingMode.SPEECH_RECOGNITION_ONLY:
                    protoUnderstandingMode =
                        packets_pb_1.AudioSessionStartPayload.UnderstandingMode.SPEECH_RECOGNITION_ONLY;
                    break;
                default:
                    protoUnderstandingMode =
                        packets_pb_1.AudioSessionStartPayload.UnderstandingMode.FULL;
                    break;
            }
            event.setAudioSessionStart(new packets_pb_1.AudioSessionStartPayload()
                .setMode(protoMode)
                .setUnderstandingMode(protoUnderstandingMode));
        }
        return this.baseProtoPacket({
            utteranceId: false,
            interactionId: false,
            conversationId: params.conversationId,
        }).setControl(event);
    }
    customEvent(name, type, params) {
        const { parameters = [], character, conversationId } = params;
        const event = new packets_pb_1.CustomEvent().setName(name).setType(type);
        if (parameters.length) {
            event.setParametersList(parameters.map((p) => new packets_pb_1.CustomEvent.Parameter().setName(p.name).setValue(p.value)));
        }
        const base = this.baseProtoPacket({
            correlationId: true,
            conversationId,
        }).setCustom(event);
        if (character) {
            base.setRouting(this.routing({ character }));
        }
        return base;
    }
    routing(props) {
        const routing = new packets_pb_1.Routing().setSource(new packets_pb_1.Actor().setType(packets_pb_1.Actor.Type.PLAYER));
        if (props === null || props === void 0 ? void 0 : props.character) {
            routing.setTarget(new packets_pb_1.Actor().setType(packets_pb_1.Actor.Type.AGENT).setName(props.character.id));
        }
        return routing;
    }
    static worldRouting() {
        const source = new packets_pb_1.Actor().setType(packets_pb_1.Actor.Type.PLAYER);
        const target = new packets_pb_1.Actor().setType(packets_pb_1.Actor.Type.WORLD);
        return new packets_pb_1.Routing().setSource(source).setTarget(target);
    }
}
exports.EventFactory = EventFactory;
